== Live & Ready

Make sure you are in the correct namespace

----
kubectl config set-context --current --namespace=myspace
----

Make sure nothing else is deployed
----
kubectl get all
No resources found in myspace namespace.
----

Deploy an application with the Live and Ready probe set

[#create-app-live-ready]
[source,bash,subs="+macros,+attributes"]
----
cat <<EOF | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myboot
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myboot
  template:
    metadata:
      labels:
        app: myboot
        env: dev
    spec:
      containers:
      - name: myboot
        image: quay.io/burrsutter/myboot:v1
        imagePullPolicy: Always
        ports:
        - containerPort: 8080
        resources:
          requests:
            memory: "300Mi"
            cpu: "250m" # 1/4 core
          limits:
            memory: "400Mi"
            cpu: "1000m" # 1 core
        livenessProbe:
          httpGet:
              port: 8080
              path: /
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 2
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 3        
EOF
----
copyToClipboard::create-app-live-ready[]


Describe the deployment

----
kubectl describe deployment myboot
...
    Image:      quay.io/burrsutter/myboot:v1
    Port:       8080/TCP
    Host Port:  0/TCP
    Limits:
      cpu:     1
      memory:  400Mi
    Requests:
      cpu:        250m
      memory:     300Mi
    Liveness:     http-get http://:8080/ delay=10s timeout=2s period=5s #success=1 #failure=3
    Readiness:    http-get http://:8080/health delay=10s timeout=1s period=3s #success=1 #failure=3
...    
----

Deploy a Service
----
kubectl apply -f apps/kubefiles/myboot-service.yml
----

Start a poller
OpenShift:
[#openshift-ip-port]
[source,bash,subs="+macros,+attributes"]
----
IP=$(kubectl get service myboot -o jsonpath="{.status.loadBalancer.ingress[0].ip}")
PORT=$(kubectl get service myboot -o jsonpath="{.spec.ports[*].port}")
----
copyToClipboard::openshift-ip-port[]

OR

Minikube:
[#minikube-ip-port]
[source,bash,subs="+macros,+attributes"]
----
IP=$(minikube ip)
PORT=$(kubectl get service/myboot -o jsonpath="{.spec.ports[*].nodePort}")
----
copyToClipboard::minikube-ip-port[]

[#curl-loop]
[source,bash,subs="+macros,+attributes"]
----
while true
do curl $IP:$PORT
sleep .3
done
----
copyToClipboard::curl-loop[]

Change the image
----
kubectl set image deployment/myboot myboot=quay.io/burrsutter/myboot:v2
----

and notice the error free rolling update:
----
Aloha from Spring Boot! 131 on myboot-845968c6ff-k4rvb
Aloha from Spring Boot! 134 on myboot-845968c6ff-9wvt9
Aloha from Spring Boot! 122 on myboot-845968c6ff-9824z
Bonjour from Spring Boot! 0 on myboot-8449d5468d-m88z4
Bonjour from Spring Boot! 1 on myboot-8449d5468d-m88z4
Aloha from Spring Boot! 135 on myboot-845968c6ff-9wvt9
Aloha from Spring Boot! 133 on myboot-845968c6ff-k4rvb
Aloha from Spring Boot! 137 on myboot-845968c6ff-9wvt9
Bonjour from Spring Boot! 3 on myboot-8449d5468d-m88z4
----

Look at the Endpoints to see which pods are part of the Service

[#get-endpoints-before]
[source,bash,subs="+macros,+attributes"]
----
kubectl get endpoints myboot -o json | jq '.subsets[].addresses[].ip'
----
copyToClipboard::get-endpoints-before[]

These are the Pod IPs that have passed their readiness probe
----
"10.129.2.40"
"10.130.2.37"
"10.130.2.38"
----

Exec into a single pod and change its readiness flag
----
kubectl exec -it myboot-845968c6ff-k5lcb /bin/bash
curl localhost:8080/misbehave
exit
----

See that the pod is no longer Ready
----
NAME                      READY   STATUS    RESTARTS   AGE
myboot-845968c6ff-9wshg   1/1     Running   0          11m
myboot-845968c6ff-k5lcb   0/1     Running   0          12m
myboot-845968c6ff-zsgx2   1/1     Running   0          11m
----

Now check the Endpoints
[#get-endpoints-after]
[source,bash,subs="+macros,+attributes"]
----
kubectl get endpoints myboot -o json | jq '.subsets[].addresses[].ip'
----
copyToClipboard::get-endpoints-after[]

And that pod is now missing from the Service's loadbalancer
----
"10.130.2.37"
"10.130.2.38"
----

Which is also self-evident in the curl loop
----
Aloha from Spring Boot! 845 on myboot-845968c6ff-9wshg
Aloha from Spring Boot! 604 on myboot-845968c6ff-zsgx2
Aloha from Spring Boot! 846 on myboot-845968c6ff-9wshg
----

Testing the Liveness Probe

----
kubectl set image deployment/myboot myboot=quay.io/burrsutter/myboot:v3
----

Let the rollout finish to completion across all 3 replicas
----
watch kubectl get pods
NAME                      READY   STATUS    RESTARTS   AGE
myboot-56659c9d69-6sglj   1/1     Running   0          2m2s
myboot-56659c9d69-mdllq   1/1     Running   0          97s
myboot-56659c9d69-zjt6q   1/1     Running   0          72s
----

and as seen in the curl loop/poller
----
Jambo from Spring Boot! 40 on myboot-56659c9d69-mdllq
Jambo from Spring Boot! 26 on myboot-56659c9d69-zjt6q
Jambo from Spring Boot! 71 on myboot-56659c9d69-6sglj
----

Edit the Deployment to point to the /alive URL
----
export KUBE_EDITOR="code -w"

kubectl edit deployment myboot
...
    spec:
      containers:
      - image: quay.io/burrsutter/myboot:v3
        imagePullPolicy: Always
        livenessProbe:
          failureThreshold: 3
          httpGet:
            path: /alive
            port: 8080
            scheme: HTTP
          initialDelaySeconds: 10
          periodSeconds: 5
          successThreshold: 1
          timeoutSeconds: 2
        name: myboot
...
----

Save and close the editor, allowing that change to rollout 

----
watch kubectl get pods
NAME                      READY   STATUS        RESTARTS   AGE
myboot-558b4f8678-nw762   1/1     Running       0          59s
myboot-558b4f8678-qbrgc   1/1     Running       0          81s
myboot-558b4f8678-z7f9n   1/1     Running       0          36s
----

Now pick one of the pods, exec into it and shoot it
----
kubectl exec -it myboot-558b4f8678-qbrgc /bin/bash
curl localhost:8080/shot
----

And you will see it get restarted
----
NAME                      READY   STATUS    RESTARTS   AGE
myboot-558b4f8678-nw762   1/1     Running   0          4m7s
myboot-558b4f8678-qbrgc   1/1     Running   1          4m29s
myboot-558b4f8678-z7f9n   1/1     Running   0          3m44s
----

Plus, your exec will be terminated
----
 kubectl exec -it myboot-558b4f8678-qbrgc /bin/bash
1000610000@myboot-558b4f8678-qbrgc:/app$ curl localhost:8080/shot
I have been shot in the head1000610000@myboot-558b4f8678-qbrgc:/app$ command terminated with exit code 137
----

And your end-users will not see any errors
----
Jambo from Spring Boot! 174 on myboot-558b4f8678-z7f9n
Jambo from Spring Boot! 11 on myboot-558b4f8678-qbrgc
Jambo from Spring Boot! 12 on myboot-558b4f8678-qbrgc
Jambo from Spring Boot! 206 on myboot-558b4f8678-nw762
Jambo from Spring Boot! 207 on myboot-558b4f8678-nw762
Jambo from Spring Boot! 175 on myboot-558b4f8678-z7f9n
Jambo from Spring Boot! 176 on myboot-558b4f8678-z7f9n
----

Clean up
----
kubectl delete deployment myboot
kubectl delete service myboot
----